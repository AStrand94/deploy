# Deployment orchestration in NAV
Documentation related to the deployment orchestration into Kubernetes using Github Deployments.

## Overview
The deployment process goes as follows (key parts of the process is explained in detail below):

1. Install the NAV deployment GitHub application to your repository (one time operation)
2. Generate a deployment using GitHub's API as part of the CI process for each deployment you want to generate for your application.
3. `hookd` receives the deployment event, and
   1. Creates deployment status using GitHub's API for invalid deployments, marking the deployment as a failure, which effectively short circuits the deployment process, or
   2. Publishes message to Kafka for all valid deployments.
4. `deployd` receives message from Kafka regarding the deployment and triggers `kubectl apply`.
5. `deployd` publishes a message regarding the outcome of the deployment back to Kafka.
6. `hookd` receives message from Kafka and adds a corresponding deployment status using GitHub's API with the result of the deployment process.

## GitHub Application
Teams that want to opt-in to the automatic deployment process must install the [NAV deployment](https://github.com/apps/nav-deployment) GitHub application in their repositories. This is a one time operation per repository. Uninstalling the application at a later stage will remove the repository from the deployment process altogether.

### Repository webhook
The NAV Deployment application defines a global webhook that will trigger when a deployment is created in any repository. This webhook will notify NAV about new deployments using [GitHub's deployment events](https://developer.github.com/v3/activity/events/types/#deploymentevent).

## GitHub Deployments
Deployments are generated by the teams themselves, using the [GitHub Deployment API](https://developer.github.com/v3/repos/deployments/#create-a-deployment).

### Environment / cluster
Use the `environment` parameter in the deployment to set the cluster name, for instance `prod-fss` or `dev-sbs`.

### Custom payload
Each deployment must contain a JSON-string in the `payload` parameter. The JSON-string must represent an object with two keys, `version` and `nais-yaml`.

#### version
This is the version of the payload itself. Use a tuple for the version number: `[<major>, <minor>, <patch>]`.

Currently the only valid version is `[0, 0, 0]`.

#### nais.yaml
The other key in the `payload` parameter is called `nais-yaml` and must contain the complete contents of your `nais.yaml` file, as a string.

## hookd
This service will receive all deployment events from GitHub.

Its main tasks are to:
* validate deployment events
* publish messages to Kafka when a deployment is created
* report deployment status back to GitHub

The validation part is done by checking if the signature attached to the deployment event is valid, and by checking the format of the deployment. Refer to the [GitHub documentation](https://developer.github.com/webhooks/securing/) as to how webhooks are secured.

## deployd
Deployd's main responsibility is to deploy resources into a Kubernetes cluster. Additionally it reports the deployment status back to hookd using Kafka.

## Developing

### Compiling hookd and deployd
[Install Golang 1.12 or newer](https://golang.org/doc/install).

Check out the repository and run `make`. Dependencies will download automatically, and you should have two binary files at `hookd/hookd` and `deployd/deployd`.

### External dependencies
Start the external dependencies by running `docker-compose up`. This will start local Kafka and S3 servers.

#### Kafka
Kafka is used as a communication channel between hookd and deployd. Hookd sends deployment requests to a `deploymentRequests` topic, which fans out
and in turn hits all the deployd instances. Deployd acts on the information, and then sends a deployment status to the `deploymentStatus` topic.
Hookd picks up replies to this topic, and publishes the deployment status to Github.

#### S3
Used as a configuration backend. Information about repository team access is stored here, and accessed on each deployment request.

The access and secret keys are as follows:

```
export S3_ACCESS_KEY=accesskey
export S3_SECRET_KEY=secretkey
```

### Simulating Github deployment requests
Start a local Kafka instance as described above. Now run your local hookd instance, disabling Github interactions:
```
hookd/hookd --github-enabled=false --listen-address=127.0.0.1:8080
```

You might want to start up `deployd` as well:
```
deployd/deployd
```

Compile the `mkdeploy` tool:
```
cd hookd/cmd/mkdeploy
make
```

You can now run the tool, generating deployment requests as you go. Run `./mkdeploy --help` to see which options you can tweak.